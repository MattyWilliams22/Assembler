\documentclass[11pt]{article}

\usepackage{fullpage}
\usepackage{graphicx}

\begin{document}

\title{
    \vspace{-2cm}
    ARM Project Final Report}
\author{Dina Duong, Maciej Rytlewski, Kritik Pant, Matty Williams}

\maketitle

\section{Assembler Structure and Implementation}

Our assembler is split into five .c files each with their own .h header file.

\begin{itemize}
    \item The first file is assemble.c which contains the main function.
    \item The second file is tokenizer.c which is responsible for parsing the text file given as a parameter and outputting an array of tokenised lines.
    \item The third file is symbolTable.c which contains the functions required to manipulate a symbol table ADT. The symbol table is used to store the address of a label so that the address can be used at the necessary points in the assembly code.
    \item The fourth file is assembleinstructions.c which contains all of the functions responsible for converting operands to their corresponding binary form and combining the binary to form a 32 bit integer.
    \item The fifth file is assemblesetup.c which is responsible for file handling, memory allocation and freeing. 
\end{itemize}

\subsection{Assembler Testing}

\begin{itemize}
    \item Testsuite
    \item Continuous integration with gitlab
    \item Print messages
    \item GDB
    \item Valgrind
\end{itemize}

\section{Raspberry Pi Implementation}

This is how we implemented Part III

\section{Extension}

\subsection{Description}

Our extension is an educational tool to help students learn about path finding algorithms. 
We do this by using game based learning through the game of snake. The user can select various search algorithms 
such as BFS, DFS, Dijkstra and A* and watch the snake search for the fruit through the grid. 
The user can also generate a random maze which helps better illustrate some searches. 
This visualisation helps students understand how the algorithms work and how they differ from each other. 

\subsection{Example of Use}


\graphicspath{ {./images/} }

% \includegraphics{example1}

\subsection{Design}

The extension is split up into the following files \[IN PROGRESS\].
\begin{itemize}
    \item Main File: This provides setup functions, game logic and allows the user to interface with the game in manual mode.
    \item Maze: This uses a maze generation algorithm to generate a random maze. Demonstrates search algorithms in more difficult situations.
    \item Search Algorithms: This provides implementations for DFS, BFS, Dijkstra and A* algorithms.
\end{itemize}

\subsection{Problems}

\begin{itemize}
    \item Manual Mode: One problem was that the user needed to be able to control the snake without pressing the Enter key after each move. This would not be possible in a regular terminal 
    so we used the terminal in non canonical mode. This allowed us to read input as soon as it was available.
    \item Animation: We needed to animate the movements of the snake. We did this by clearing the terminal and redrawing the grid after each move. This could possibly be improved by using external libraries.
    \item Printing searches: One significant problem was printing the searches as they happened. While the search happened, this was not educational on its own as there was no 
    visualisation of the search. We experimented with having a separate grind to show the search as it happened but this was not very effective. We decided to pause the game every time the fruit is reached, 
    show the search happening and the shortest path found, then continue the search. This was a good compromise between showing the search and not interrupting the game too much.
    \item Maze Generation: We also found it difficult to integrate our maze generation algorithm with the game. \[DESCRIBE HOW WE DID IT\]
    \item Memory Leaks: We also had memory leaks in our code which we fixed using Valgrind.
\end{itemize}

\subsection{Extension Testing}
As our project was a game which requires human interaction it was hard to test. We mainly tested by playing the game repeatedly and trying unusual sequences of inputs or actions such as reversing direction of the snake, 
touching corners, crashing into walls or the body of the snake etc. However, it is impossible for us to predict every possible sequence of actions a user might take. Therefore, our testing may not be very effective without 
a large number of users testing the game. However, since Snake is a fairly simple game, it is likely that our testing is sufficient.

\section{Group Reflection}

As a group we were ... at communicating and splitting work up between the group.
Next time, we would do ... differently. We would keep ... the same.

\section{Individual Reflections}

\subsection{Dina Duong}

abcd

\subsection{Maciej Rytlewski}

abcd

\subsection{Kritik Pant}

I believe that I fitted well into the group and got along with everyone. I helped with the development of the Emulator, Assembler and the Extension by 
making design decisions and implementing code which others were able to use and build upon. While I initially thought that the Emulator would be fairly easy, 
I found some parts quite difficult such as branching and dealing with different access modes. I also found it difficult to solve memory issues, often relying on 
other members of the group to help me. This was especially true in the Assembler where I worked on the implementation of the Symbol Table. While I found it fairly 
simple to build a basic table using a linked list similar to Java, I found it difficult to diagnose and solve memory issues arising from my implementation. 
Unexpectedly, I found the Extension to be a strength of mine due to my familiarity with path-finding algorithms and the game of Snake. I ran into some difficult 
problems described above but, due to my knowledge of the Linux command line, I was able to solve them.
\newline
Through this project, I learnt the importance of maintaing good communication and coordination between group members. Since we always kept each other updated 
on progress and what we were working on, we were able to avoid duplication of work and it was easier for members to help each other. I aim to continue this in 
future projects. I also improved my ability to use Git. Previously, I had only used Git as a version tracking system on personal projects. However, this project 
really showed me the power of Git as a collaboration tool. I learnt how to use branches to experiment with code and how to use merge requests to review and merge code. 
I also learnt how to use Continuous Integration to speed up testing. I believe that these skills will be helpful in future projects and I aim to research more about 
the features of Git and Gitlab to improve my workflow.

\subsection{Matty Williams}

... is how well I fit into the group.
My strengths were ... .
My weaknesses were ... .
With a different group of people I would do ... differently but do ... the same way. 

\end{document}
